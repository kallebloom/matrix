#include "Matrix.h"
#include <iostream>

//конструктор с параметрами
//rows-число строк (по умолчанию rows=1)
//cols-число столбцов(по умолчанию cols=1)
//fill-заполнитель матрицы(по умолчанию fill=0)
Matrix::Matrix(int rows, int cols, double fill):
// устанавливаем размеры матрицы
_rows(rows),
_cols(cols)
{
    // Выделяем память под массив строк
    _matrix = new Row [_rows];

    // Устанавливаем необходимы размер для каждой строки и заполняем матрицу желаемым значением
    for (int i = 0; i < _rows; ++i)
        _matrix[i].resize(_cols, fill);
}

// Конструктор копирования
Matrix::Matrix(const Matrix &c):
// Устанавливаем размеры матрицы
_rows(c._rows),
_cols(c._cols)
{
    // Выделяем память под массив строк
    _matrix = new Row [_rows];

    // Каждую строку новой матрицы инициализируем соответствующей строкой изначальной матрицы
    for (int i = 0; i < _rows; ++i)
        _matrix[i] = c._matrix[i];
}

// Деструктор
Matrix::~Matrix()
{
    // Удаляем память, отведунную под массив строк
    delete [] _matrix;
}

// Функция транспонирования матрицы
Matrix Matrix::transpose() const
{
    Matrix result(this->_cols, this->_rows); // Результирующая матрица, размеры которой
                                             // противоположны размерам исходной матрицы

    // В цикле идём по всем элементам исходной матрицы
    // и записываем их на места соответствующих элементов
    // результирующей матрицы (в результирующей матрице в
    // итоге будут элементы исходной матрицы, отражённые
    // относительно главной диагонали)
    for (int i = 0; i < _rows; ++i)
        for (int j = 0; j < _cols; ++j)
            result._matrix[i][j] = _matrix[j][i];

    // Возвращаем результат транспонирования
    return result;
}

// Перегрузка оператора вывода строки по индексу
Row &Matrix::operator[](int index)
{
    // Возвращаем ссылку на желаемую строку
    return _matrix[index];
}

// Перегрузка оператора вывода строки по индексу (константный)
const Row &Matrix::operator[](int index) const
{
    // Возвращаем константную ссылку на желаемую строку
    return _matrix[index];
}

// Перегруженный оператор вывода из потока
std::istream &operator>>(std::istream &input, Matrix &c)
{
    // Идём по строкам матрицы
    for (int i = 0; i < c._rows; ++i)
        // Вводим очередную строку матрицы
        input >> c._matrix[i];

    // Возвращаем ссылку на поток
    return input;
}

// Перегруженный оператор ввода в поток
std::ostream &operator<<(std::ostream &output, const Matrix &c)
{
    // Идём по строкам матрицы
    for (int i = 0; i < c._rows; ++i)
        // Выводим очередную строку матрицы
        output << c._matrix[i] << std::endl;

    // Возвращаем ссылку на поток
    return output;
}

// Перегруженный оператор сложения матриц, результат отдельно
Matrix Matrix::operator+(const Matrix &c) const
{
    // Результирующая матрица, равная изначально первой матрице
    Matrix result(*this);
    // Если количество строк и столбцов первой матрицы
    // совпадает с количеством соответственно строк и
    // столбцов второй матрицы
    if (_rows == c._rows && _cols == c._cols)
    {
        // Идём по строкам матрицы
        for (unsigned i = 0; i < _rows; ++i)
            // Идём по элементам очередной строки
            for (unsigned j = 0; j < _cols; ++j)
                // Прибавляем к каждому элементу результируещей
                // матрицы (который изначально совпадает с
                // соответствующим элементом первой матрицы)
                // соответствующий элемент второй матрицы
                result._matrix[i][j] += c._matrix[i][j];
    }


    // Возвращаем результирующую матрицу
    return result;
}

// Перегруженный оператор сложения матриц, результат в правой матрице
const Matrix &Matrix::operator+=(const Matrix &c)
{
    // Сохраняем в правую матрицу результат
    // сложения правой и левой матриц посредством
    // перегруженной операции сложения матриц
    *this = *this + c;

    return *this;
}

// Перегруженный оператор вычитания матриц, результат отдельно
Matrix Matrix::operator-(const Matrix &c) const
{
    // Используется уже реализованный оператор
    // умножения матрицы на число и оператор
    // сложения матриц
    return *this + (-1.0) * c;
}

// Перегруженный оператор вычитания матриц, результат в левой матрице
const Matrix &Matrix::operator-=(const Matrix &c)
{
    // Используется уже реализованный оператор
    // вычитания матриц
    *this = *this - c;

    return *this;
}

// Перегруженный оператор умножения двух матриц, результат отдельно
Matrix Matrix::operator*(const Matrix &c) const
{
    Matrix result(_rows, c._cols); // Результирующая матрица имеет столько же
                                     // строк, сколько и левая матрица, и столько же
                                     // столбцов, сколько правая

    // Умножение матриц возможно, только если количество столбцов левой матрицы и количество строк правой совпадают
    if (_cols == c._rows)
    {
        // Идём по строкам левой матрицы
        for (int i = 0; i < _rows; ++i)
            // Идём по столбцам правой матрицы
            for (int j = 0; j < c._cols; ++j)
                // Идём по столбцам левой (и по строка правой) матрицы
                for (int k = 0; k < _cols; ++k)
                    // Формируем очередной элемент результирующей матрицы
                    result._matrix[i][j] += _matrix[i][k] * c._matrix[k][j];
    }

    // Возвращаем результат умножения
    return result;
}

// Перегруженный оператор умножения двух матриц, результат в левой матрице
const Matrix &Matrix::operator*=(const Matrix &c)
{
    // Используется уже реализованный оператор
    // умножения матриц
    *this = *this * c;

    return *this;
}

// Перегруженный оператор умножения матрицы на число
// (матрица слева, число справа), результат отдельно
Matrix operator*(const Matrix &c, const double d)
{
    Matrix result(c); // Изначально результирующая матрица
                        // совпадает с исходной

    // Каждый элемент исходной матрицы умножаем на требуемое число
    for (int i = 0; i < c._rows; ++i)
        for (int j = 0; j < c._cols; ++j)
            result._matrix[i][j] *= d;

    // Возвращаем результирующую матрицу
    return result;
}

// Перегруженный оператор умножения матрицы на число
// (матрица слева, число справа), результат в матрице
const Matrix &operator*=(Matrix &c, const double d)
{
    // Используется уже реализованный оператор
    // умножения матрицы на число
    c = c * d;

    return c;
}

// Перегруженный оператор умножения матрицы на число
// (матрица справа, число слева), результат отдельно
Matrix operator*(const double c, const Matrix &d)
{
    // Используется уже реализованный оператор
    // умножения матрицы на число
    return d * c;
}
// Перегруженный оператор сравнения матриц
bool Matrix::operator==(const Matrix &c) const
{
    // Если размеры матриц не совпадают, то матрицы заведомо не равны
    if (_rows != c._rows || _cols != c._cols)
        return false;

    // Если на какие-либо строки матриц различаются,
    // то матрицы не равны
    for (unsigned i = 0; i < _rows; ++i)
        if (_matrix[i] != c._matrix[i])
            return false;

    // Если как размеры, так и все элементы матриц совпадают,
    // то матрицы равны
    return true;
}

// Перегруженный оператор неравенства матриц
bool Matrix::operator!=(const Matrix &c) const
{
    // Используется уже реализованный оператор сравнения матриц
    return !(*this == c);
}

// Перегруженный оператор присваивания
const Matrix &Matrix::operator=(const Matrix &c)
{
    // Проверка на самоприсваивание
    if (this != &c)
    {
        // Если размеры матриц не совпадают
        if (_rows != c._rows || _cols != c._cols)
        {
            // Очищаем память из-под старой матрицы
            delete [] _matrix;

            // Устанавливаем новые размеры
            _rows = c._rows;
            _cols = c._cols;

            // Выделяем память под новую матрицу
            _matrix = new Row [_rows];

            // Устанавливаем необходимый размер для каждой строки
            for (int i = 0; i < _rows; ++i)
                _matrix[i].resize(_cols);
        }

        // Заполняем новую матрицу элементами из присваиваемой
        for (int i = 0; i < _rows; ++i)
            _matrix[i] = c._matrix[i];
    }

    return *this;
}
